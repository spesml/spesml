---
layout: default
title: Technical Viewpoint
nav_order: 9
parent: SpesML Plugin
permalink: /plugin/technical_viewpoint.html
---
# ![Technical Viewpoint](/images/technical_viewpoint/TechnicalViewpoint.png){:height="30px" width="30px"}{:class="img-responsive"}SpesML Plugin - Technical Viewpoint

## Overview
The technical view, as instance of the technical viewpoint, is the last step on the way to platform-specific models. Here, technical elements represent the system finally for specific platforms while logical components of platform-independent models of the [logical view](/plugin/logical_viewpoint.html) can be mapped to software elements deployed on execution units of these specific platforms. This is needed to be able to generate code out of the models and enable further system engineering activities including software element ("task") optimization/scheduling.

For a better understanding of the concept of the technical viewpoint, please have a look at the respective [theoretical concept documentation](/concepts/modeling_framework/technical_viewpoint.html). 
The [specific well-formedness rules for the technical viewpoint](/concepts/modeling_framework/technical_viewpoint.html#well-formedness-rules-specific-for-the-technical-viewpoint) are integrated into the SpesML plugin via MagicDraw Validation Rules, like all other well-formedness rules within the SpesML project.
In the following, we will explain the realization/implementation of the technical viewpoint within our SpesML plugin.

## Method
Within the technical view it is possible to models technical architectures. Technical architectures can be composed of various component types to represent the technical specifications of a system (see the concept in [Figure 1](#figureConcept)). Logical components of the [logical view](/plugin/logical_viewpoint.html) can then be mapped onto these technical components. A technical architecture can not only represent mechanical, electrical/electronic, or mechatronic elements (or any generic technical element) but also a software execution subsystem. A software execution subsystem is a model of the pure software part of the system including its execution elements. It contains a software element architecture with software elements onto which the software-relevant logical components of the [logical view](/plugin/logical_viewpoint.html) are mapped. Furthermore, it contains an execution platform consisting of execution units like ECUs and communication elements like buses. An allocation of software elements to execution units realizes the deployment.

<a name="figureConcept"></a>
![Technical Architecture Concept](/images/technical_viewpoint/TVP_Element_Overview.png){:class="img-responsive" style="display:block; margin-left:auto; margin-right:auto"}
<div align="center"><b>Figure 1: </b><em>The concept of the implemented technical viewpoint.</em></div>

Regarding the development process, one step is to create the technical representation of the system with all available components of the technical viewpoint (as far as needed). This should include at least one software execution subsystem. To model such a software execution subsystem with all its software elements and execution units is another step. Since the logical architecture should be mapped next with the technical architecture, we already recommended building the logical and now the technical architecture in a way that a 1:1 mapping is possible between logical and technical components. In addition, it simplifies the process when already in the logical view the pure software-related logical components are separated from the other logical components. Then, it is easy to map them directly to a technical component representing the software execution subsystem and internally to the defined software elements. However, we do not force a 1:1 mapping and it is also very usual that some technical components exist that do not have a match within the logical architecture, because they were not needed for a platform-independent model, e.g., in the logical view, but still contribute to the technical representation of an actual platform. After the mapping of logical to technical components (including the software elements), the final deployment needs to be done by mapping the software elements to the added execution units. It should be said that the development is not a strict step-by-step process, but is usually done by building the technical architecture with components and elements of the software execution subsystem in parallel with creating the matching between logical and technical view and within the technical view regarding the deployment.

We recommend that the software execution subsystem is modeled on a separate (lower) granularity level (see [theoretical concept](/concepts/modeling_framework/technical_viewpoint.html)). How to create a new granularity level is described [here](/plugin/general_concepts/granularity_transitions.html). However, we also allow in the tool plugin that the internal software execution subsystem with its software elements and execution elements can be modeled on the same level (just hierarchical), i.e., in the same MagicDraw project directly inside the [Software Execution Component](#software-execution-component).

## Structure
The SpesML plugin has a separate folder for the technical view, called Technical View (see [Figure 2](#figureElements)). Within this folder, it is possible to create folders for technical components ([Technical Package](#technical-package)), for technical interfaces types ([Technical Interface Types Package](#technical-interface-types-package)), and for technical tracing ([Technical Tracing Package](#technical-tracing-package)). Inside the Technical Tracing Package, all diagrams regarding tracing can be created: [Technical Tracing Map](#technical-tracing-map), [TechnicalToLogical Matrix](#technicaltological-matrix), and [TechnicalToRequirement Matrix](#technicaltorequirement-matrix). Inside the Technical Interface Types Package, all possible interface types can be created that are usable for the interfaces between technical elements (see [Technical Interface](#technical-interface)), and further Technical Interface Types Packages for a better organization. 

Inside the Technical Package, other Technical Packages can be created as well for better organization, but more important are the possibilities of the component creations. The generic [Technical Component](#technical-component) can be used for everything. If something more specific is needed, then the [Mechanical](#mechanical-component), [Electrical/Electronic](#electricalelectronic-component) or [Mechatronic Components](#mechatronic-component) are available. In addition, the modeler can define a [Technical Context](#technical-context) inside a Technical Package. The Technical Context behaves like a Technical Component, but can already be placed in the Technical View folder to create a starting point for the system and a possibility to represent the connected external systems and [Technical Actors](#technical-actor), which can be created in a Technical Package as well. To indicate that a component is representing an external (sub-)system, the corresponding "External" part property can be set to "Yes". 

Now, only the software execution subsystem is missing. For better guidance, it is only possible to create first a [Software Execution Package](#software-execution-package) inside a Technical Package. Within a Software Execution Package, the modeler can then create [Software Execution Components](#software-execution-component), which are the containers for everything of a software execution subsystem. A Software Execution Package can also contain [Software Element Architectures](#software-element-architecture) and [Software Elements](#software-element), as well as [Execution Elements](#execution-element) and [Communication Elements](#communication-element). A execution platform element does not exist explicitly since the Software Execution Component can directly contain Execution Elements and Communication Elements in its [Technical Internal Component Diagram](#technical-internal-component-diagram) to represent the topology of the execution platform.

<a name="figureElements"></a>
![Technical Elements Of The Plugin](/images/technical_viewpoint/TVP_elements_in_plugin.png){:class="img-responsive" style="display:block; margin-left:auto; margin-right:auto"}
<div align="center"><b>Figure 2: </b><em>An example collection of all technical elements implemented inside the SpesML plugin.</em></div>

Every component (and the Technical Context) can have its own [Technical Internal Component Diagram](#technical-internal-component-diagram) where its containing elements are represented. Depending on the owner of the diagram, only some internal components can be placed in the diagram:
- The Technical Component as well as the Technical Context can contain Technical, Mechanical, Electrical/Electronic, Mechatronic, and Software Execution Components. 
- Mechatronic Components can contain Mechatronic, Mechanical, Electrical/Electronic, and Software Execution Components. 
- Mechanical and Electrical/Electronic Components can only contain internal components of their own type. 
- Software Execution Components can contain Software Element Architectures, Execution Elements and Communication Elements. 
- Software Element Architectures can contain Software Elements. 

No behavior is modeled inside the technical view, which is why the composition of the components inside the (nested) diagrams is the main part of the technical view, together with the component mapping and the allocation of Software Elements to Execution Elements for the deployment.

To connect this composition of technical elements, it is possible to place interfaces (proxy ports) on every element and connect them with a Connector if both ports have the same interface type (defined in a Technical Interface Types Package). All elements can be connected via a generic [Technical Interface](#technical-interface), which is defined by its Technical Interface Type. Technical Interface Types can have [Channels](#channel), which are inherited from the [Universal Interface Model](/concepts/modeling_framework/uim.html). Therefore it is possible to represent/model communication flows between technical elements (but without actual behavior!). An exception is the Software Element Architecture because it does not make sense to connect Software Elements in Software Element Architectures with the physical elements outside of Software Element Architectures, which is why Software Element Architectures cannot be connected in any way with other elements. However, the Software Elements themselves inside Software Element Architecture can be connected among each other again with Technical Interfaces.

To match/trace logical elements to technical elements or actually the other way around, you can create and fill a [TechnicalToLogical Matrix](#technicaltological-matrix) inside the [Technical Tracing Package](#technical-tracing-package). The same goes for technical elements to requirements with a [TechnicalToRequirement Matrix](#technicaltorequirement-matrix).

Regarding the deployment, it is possible to create allocation matrices for a [Software Execution Component](#software-execution-component) (similar to a [Technical Internal Component Diagram](#technical-internal-component-diagram)). These allocation matrices can only be added directly to a Software Execution Component (like adding a diagram to it) and not anywhere else like to a normal Technical Package. You can create a [TaskInstanceToExecution Allocation Matrix](#taskinstancetoexecution-allocation-matrix) if you want to allocate [Software Element](#software-element) instances to [Execution Element](#execution-element) instances, i.e., modeling the deployment of Software Elements to Execution Elements. The same can be done with a [TaskTypeToExecution Allocation Matrix](#tasktypetoexecution-allocation-matrix), but now you do not do it with instances but defined types of these elements. To allocate then Software Element ports to Execution Component ports, you can use a [PortToExecution Allocation Matrix](#porttoexecution-allocation-matrix).


## How to model
TODO: Should be done if the technical viewpoint is completely realized in the plugin (and in a final state).




## Elements
### ![Technical View](/images/technical_viewpoint/TechnicalViewpoint.png){:class="img-responsive"}Technical View
This element is a *UML/SysML Package* with a dedicated stereotype that allows defining an adequate SpesML model structure and guides users by restricting what elements and diagrams can be created below this package for the [technical view](/plugin/technical_viewpoint.html). This package usually contains only further packages to separate different purpose categories within the technical view. In addition, it is already possible to create a [Technical Context](#technical-context) as a starting point.

### ![Technical Tracing Package](/images/technical_viewpoint/TechnicalTracingPackage.png){:class="img-responsive"}Technical Tracing Package
This element is a *UML/SysML Package* with a dedicated stereotype that allows defining an adequate SpesML model structure and guides users by restricting what elements and diagrams can be created below this package for the [technical view](/plugin/technical_viewpoint.html). This package usually contains only tracing-related relation maps and matrixes.

### ![Technical Interface Types Package](/images/technical_viewpoint/TechnicalInterfaceTypesPackage.png){:class="img-responsive"}Technical Interface Types Package
This element is a *UML/SysML Package* with a dedicated stereotype that allows defining an adequate SpesML model structure and guides users by restricting what elements and diagrams can be created below this package for the [technical view](/plugin/technical_viewpoint.html). This package usually contains only interface types that can be used for [Technical Interfaces](#technical-interface).

### ![Technical Package](/images/technical_viewpoint/TechnicalPackage.png){:class="img-responsive"}Technical Package
This element is a *UML/SysML Package* with a dedicated stereotype that allows defining an adequate SpesML model structure and guides users by restricting what elements and diagrams can be created below this package for the [technical view](/plugin/technical_viewpoint.html). This package usually contains only standard technical components like [Technical](#technical-component), [Mechanical](#mechanical-component), [Electrical/Electronic](#electricalelectronic-component) and [Mechatronic Components](#mechatronic-component), and context-related elements like [Technical Contexts](#technical-context) and [Technical Actors](#technical-actor). In addition, it can also contain [Software Execution Components](#software-execution-component), which are the entry point for software execution subsystem elements/models.

### ![Software Execution Package](/images/technical_viewpoint/SoftwarePackage.png){:class="img-responsive"}Software Execution Package
This element is a *UML/SysML Package* with a dedicated stereotype that allows defining an adequate SpesML model structure and guides users by restricting what elements and diagrams can be created below this package for the [technical view](/plugin/technical_viewpoint.html). This package contains only elements regarding the software execution subsystem. It includes [Software Execution Components](#software-execution-component), [Software Element Architectures](#software-element-architecture), [Software Elements](#software-element), [Execution Elements](#execution-element) and [Communication Elements](#communication-element).



### ![Technical Context](/images/technical_viewpoint/TechnicalContext.png){:class="img-responsive"}Technical Context
The Technical Context is a separate element but it mainly behaves as a standard [Technical Component](#technical-component) like containing a [Technical Internal Component Diagram](#technical-internal-component-diagram). 
Its purpose is to act as a starting point for the system model, where the system under development is represented as only one component, usually a [Technical Component](#technical-component), and the connected external systems and [Technical Actors](#technical-actor) can be modeled to show the environment/context of the system under development. 
A component can be defined as external (in a specific diagram like the one from the Technical Context) by changing the property *external* of this component from *No* to *Yes*. Another property is *system under development* with which the modeler can specify if a component is the current system under development or not (the latter is the default).
To support the purpose as starting point and initial overview, the Technical Context is the only element (besides packages) that can be directly placed in the top [Technical View](#technical-view) folder. If a user opens the technical view, it will directly see the Technical Context element and can open it to see first the context and then go deeper into the system under development.

### ![Technical Actor](/images/technical_viewpoint/TechnicalActor.png){:class="img-responsive"}Technical Actor
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it. 
In the case of the Technical Actor, it prevents the creation of any sub-element below it including any diagram except [Technical Interfaces](#technical-interface). 
The Technical Actor just indicates an actor that has a connection to the system under development without any further modeling of this actor. Therefore, the Technical Actor makes in most cases only sense to be placed in the [Technical Context](#technical-context). 
To model the connections with the system under development, it is possible to add [Technical Interfaces](#technical-interface) to the Technical Actor and connect them with Technical Interfaces of other components, usually, the one representing the system under development.



### ![Technical Component](/images/technical_viewpoint/TechnicalComponent.png){:class="img-responsive"}Technical Component
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it. 
A Technical Component is a generic component and can represent everything. It can be used as a placeholder and if it is not needed to specify the modeled element further with it or if it is a container for components of different disciplines.
A Technical Component can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place further [Technical](#technical-component), [Mechanical](#mechanical-component), [Electrical/Electronic](#electricalelectronic-component), [Mechatronic](#mechatronic-component) and [Software Execution Components](#software-execution-component) in this diagram. 
A Technical Component can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Mechanical Component](/images/technical_viewpoint/MechanicalComponent.png){:class="img-responsive"}Mechanical Component
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Mechanical Component is a specific component of the mechanical engineering discipline. It can be used to model mechanical parts of the system, like e.g., the mechanical presence of a door or a motor shaft.
A Mechanical Component can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place further [Mechanical Components](#mechanical-component) in this diagram. 
A Mechanical Component can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Mechatronic Component](/images/technical_viewpoint/MechatronicComponent.png){:class="img-responsive"}Mechatronic Component
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Mechatronic Component is a specific fusion component of the mechanical and electrical engineering disciplines. It can be used to model parts of the system that have mechanical as well as electrical shares, like e.g., an electrical motor. It usually represents a container that you can (theoretically) refine even more into (in the end) [Mechanical](#mechanical-component) and [Electrical/Electronic Components](#electricalelectronic-component).
A Mechatronic Component can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place [Mechanical](#mechanical-component), [Electrical/Electronic](#electricalelectronic-component), and further [Mechatronic Components](#mechatronic-component) in this diagram, as well as [Software Execution Components](#software-execution-component). 
A Mechatronic Component can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Electrical/Electronic Component](/images/technical_viewpoint/ElectronicComponent.png){:class="img-responsive"}Electrical/Electronic Component
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
An Electrical/Electronic (E/E) Component is a specific component of the electrical engineering discipline. It can be used to model E/E parts of the system, like e.g., a light or a sensor. Often, electrical parts contain already mechanical parts (like the case), which is why they can also be modeled as [Mechatronic Components](#mechatronic-component). The user can then decide what part should be viewed/identified.
An Electrical/Electronic Component can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place further [Electrical/Electronic Components](#electricalelectronic-component) in this diagram. 
An Electrical/Electronic Component can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Software Execution Component](/images/technical_viewpoint/SoftwareExecutionSubsystem.png){:class="img-responsive"}Software Execution Component
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Software Execution Component is a container representing the software execution subsystem (see [technical viewpoint concept](/concepts/modeling_framework/technical_viewpoint.html)). It is used by the software engineering discipline to model the software part of the system (and its execution environment). 
A Software Execution Component can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place mainly [Execution](#execution-element) and [Communication Elements](#communication-element) in this diagram, but also [Software Element Architectures](#software-element-architecture) if wanted. 
In this implementation, we have simplified the structure of a Software Execution Component and directly allow the placing of [Execution](#execution-element) and [Communication Elements](#communication-element) in its diagram without adding an additional container for them in form of a execution platform. Therefore, the Software Execution Component directly represent the execution environment (its topology).
A Software Execution Component can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Execution Element](/images/technical_viewpoint/ExecutionComponent.png){:class="img-responsive"}Execution Element
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
An Execution Element is a specific (atomic) component of the software execution subsystem that represents an execution unit, like an ECU, on which [Software Elements](#software-element) can be deployed and executed.
An Execution Element cannot be further specified by adding a diagram to it. It is an atomic unit on which [Software Elements](#software-element) can be mapped to realize the (software) deployment.
An Execution Element can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components, in this case other [Execution Elements](#execution-element) or [Communication Elements](#communication-element) (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Communication Element](/images/technical_viewpoint/CommunicationComponent.png){:class="img-responsive"}Communication Element
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Communication Element is a specific (atomic) component of the software execution subsystem that represents a communication unit, like a CAN bus, connecting [Execution Elements](#execution-element). However, it is not needed to have always specifically modeled Communication Elements between [Execution Elements](#execution-element).
A Communication Element cannot be further specified by adding a diagram to it. It is an atomic unit that can mainly be used to indicate/model communication elements between [Execution Elements](#execution-element) (if wanted).
A Communication Element can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components, in this case [Execution Elements](#execution-element) (to model just the composition or to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).

### ![Software Element Architecture](/images/technical_viewpoint/TaskArchitecture.png){:class="img-responsive"}Software Element Architecture
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Software Element Architecture is a container element for [Software Elements](#software-element) to represent the software part of a software execution subsystem (represented by [Software Execution Component](#software-execution-component)).
A Software Element Architecture can be further specified by adding a [Technical Internal Component Diagram](#technical-internal-component-diagram) to it. With such an owner it is possible to place [Software Elements](#software-element) in this diagram. 
A Software Element Architecture does NOT provide any syntactic interface via e.g., [Technical Interfaces](#technical-interface). It is only used as a virtual container for all the [Software Elements](#software-element) and does not need to have any connection with other (physical) elements.

### ![Software Element](/images/technical_viewpoint/TaskComponent.png){:class="img-responsive"}Software Element
This element is based on a *SysML Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications. In addition, it restricts that only certain sub-elements can be created below it.
A Software Element is a specific (atomic) component representing a single software element that was mapped from the [logical view](/plugin/logical_viewpoint.html) and should be executed on an execution unit represented by an [Execution Element](#execution-element).
A Software Element cannot be further specified by adding a diagram to it. It is an atomic unit on which software-related Logical Components of the [logical viewpoint](/plugin/logical_viewpoint.html) can be mapped, and which itself can then be mapped on [Execution Elements](#execution-element) to realize the final (software) deployment with such an allocation.
A Software Element can provide a syntactic interface via [Technical Interfaces](#technical-interface), which can be used to connect this component to other components, in this case, other Software Elements (to model actual information flow if the used [Technical Interface Type](#technical-interface-type) contains [Channels](#channel)).



### ![Technical Interface](/images/technical_viewpoint/TechnicalInterface.png){:class="img-responsive"}Technical Interface
This element is based on a *SysML Proxy Port* with a dedicated stereotype that allows defining where the element can be placed and other specifications.
A Technical Interface is used to connect different technical elements/components generically. 
It can be specified further by using [Technical Interface Types](#technical-interface-type) and [Channels](#channel) to model the connection between the elements and even actual information flows (via the channels).
A Technical Interface is nothing else than a port that can be placed on a technical element. If another technical element has also such a port/interface with the same [Technical Interface Type](#technical-interface-type)], the user can connect these two ports with a *Connector* line.

### ![Technical Interface Type](/images/technical_viewpoint/TechnicalInterfaceType.png){:class="img-responsive"}Technical Interface Type
This element is based on a *SysML Interface Block* with a dedicated stereotype that allows defining where the element can be placed and other specifications.
A Technical Interface Type is used to specify the type of a [Technical Interface](#technical-interface). It needs to be defined separately in a [Technical Interface Types Package](#technical-interface-types-package) and can then be used to fill the *Type* property of a [Technical Interface](#technical-interface).
A Technical Interface Type can either contain a Value Property (e.g., a specific enumeration) or a [Channel](#channel) (or multiple ones). 

### ![Channel](/images/universal_interface_model/Channel.png){:class="img-responsive"}Channel
This element is based on a *SysML Flow Property* with a dedicated stereotype that allows for defining the flow direction and other specifications. Its concept is explained in the [Universal Interface Model](/concepts/modeling_framework/uim.html). It can be added as an element to a [Technical Interface Type](#technical-interface-type). Channels enable signal/information transport between elements that are connected with an interface connection that has such an interface type (with a channel). A channel has a type (the type of the transported signal/information), which can be any pre-defined basic data type or a new user-defined data type (see [Data Types](/plugin/data_types.html)).



## Diagrams
### ![Technical Tracing Map](/images/diagrams/map.png){:class="img-responsive"}SpesML Technical Tracing Map
This relation map shows technical elements like Technical Components, Mechanical Components, etc. and to what [Requirements](/plugin/requirements_viewpoint.html#requirement), [Functional Component](/plugin/functional_viewpoint.html#function) or [Logical Components](/plugin/logical_viewpoint.html#logical-component) these elements are tracing to. By default, all technical elements are shown but it is also possible to drag & drop a single technical element to the relation map to show only the particular relationships.

### ![TechnicalToLogical Matrix](/images/diagrams/matrix.png){:class="img-responsive"}SpesML TechnicalToLogical Matrix
This matrix allows to create relationships between elements of the [technical view](/plugin/technical_viewpoint.html#technical-view) and elements of the [logical view](/plugin/logical_viewpoint.html#logical-viewpoint).

### ![TechnicalToRequirement Matrix](/images/diagrams/matrix.png){:class="img-responsive"}SpesML TechnicalToRequirement Matrix
This matrix allows to create relationships between elements of the [technical view](/plugin/technical_viewpoint.html#technical-view) and [requirement view](/plugin/requirements_viewpoint.html#requirements).

### ![Technical Internal Component Diagram](/images/diagrams/composite_structure.png){:class="img-responsive"}SpesML Technical Internal Component Diagram
This diagram is based on a *UML Composite Structure Diagram/SysML Internal Block Diagram* and provides a reduced diagram toolbar related to SpesML for the [technical view](/plugin/technical_viewpoint.html). Note that intentionally any technical element cannot be created using the diagram toolbar. Instead, it is recommended to create these elements by dragging/dropping a technical element into the diagram. Depending on the owner of the diagram, only certain elements are allowed to be placed in this diagram. For example, for a Technical Internal Component Diagram of a Mechanical Component, it is only allowed to place further Mechanical Component, for a Technical Internal Component Diagram of a Software Execution Component it is only allowed to place Execution Elements and Communication Elements, etc. If you drag and drop a wrong element inside a diagram, you will get a warning message that will tell you which elements are allowed for this specific diagram.

### ![TaskInstanceToExecution Allocation Matrix](/images/diagrams/matrix.png){:class="img-responsive"}TaskInstanceToExecution Allocation Matrix
This matrix allows to create relationships between [Software Elements](#software-element) in [Software Element Architectures](#software-element-architecture) and [Execution Elements](#execution-element) in [Software Execution Components](#software-execution-component). This creates an allocation between Software Elements and Execution Elements that represents the deployment of these software elements on these execution units. All of this happens on the instance level, meaning that every instance/part of a Software Element and an Execution Element can be allocated separately. To use this matrix, a scope needs to be set (above the matrix diagram). As the description at the bottom of the matrix diagrams indicates, the row scope should be the Software Element Architecture of the wanted Software Elements and the column scope the Software Execution Component of the wanted Execution Element.

### ![TaskTypeToExecution Allocation Matrix](/images/diagrams/matrix.png){:class="img-responsive"}TaskTypeToExecution Allocation Matrix
This matrix allows to create relationships between [Software Elements](#software-element) in [Software Element Architectures](#software-element-architecture) and [Execution Elements](#execution-element) in [Software Execution Components](#software-execution-component). This creates an allocation between Software Elements and Execution Elements that represents the deployment of these software elements on these execution units. All of this happens on the type level, meaning that only the defined types/blocks of a Software Element and an Execution Element can be allocated (instances of them cannot be allocated separately!). To use this matrix, a scope needs to be set (above the matrix diagram). As the description at the bottom of the matrix diagrams indicates, the row scope should be the package in which the wanted Software Elements are defined, and the column scope the package in which the wanted Execution Elements are defined.

### ![PortToExecution Allocation Matrix](/images/diagrams/matrix.png){:class="img-responsive"}PortToExecution Allocation Matrix
This matrix allows to create relationships between [Technical Interfaces](#technical-interface) (ports) of [Software Elements](#software-element) in [Software Element Architectures](#software-element-architecture) and [Technical Interfaces](#technical-interface) (ports) of [Execution Elements](#execution-element) in [Software Execution Components](#software-execution-component). This creates an allocation between Software Element ports and Execution Element ports, which supports the deployment of these software elements on these execution units. To use this matrix, a scope needs to be set (above the matrix diagram). As the description at the bottom of the matrix diagrams indicates, the row scope should be the package in which the wanted Software Elements ports are defined, and the column scope is the package in which the wanted Execution Element ports are defined. The port allocation is only needed on the type level because together with a [TaskInstanceToExecution Allocation Matrix](#taskinstancetoexecution-allocation-matrix), it is then always possible which port instances (depending on the Software Element and Execution Element instance) are meant to be mapped.
